{% extends "base.html" %}
{% block title %}Configuration Â· TG Sentinel{% endblock %}

{% block content %}
<form id="config-form" class="d-grid gap-4" novalidate>
    <section class="card" aria-labelledby="telegram-config-heading">
        <div class="card-header d-flex justify-content-between align-items-center" style="cursor: pointer;" data-bs-toggle="collapse" data-bs-target="#telegram-config-body" aria-expanded="false" aria-controls="telegram-config-body">
            <div>
                <h1 class="card-title mb-0" id="telegram-config-heading">
                    <i class="bi bi-chevron-right collapse-icon me-2"></i>
                    Telegram Account
                </h1>
                <small class="text-muted">Manage MTProto authentication</small>
            </div>
            <button class="btn btn-outline-primary btn-sm" type="button" id="btn-reauth" onclick="event.stopPropagation();">Reauthenticate</button>
        </div>
        <div class="collapse card-body" id="telegram-config-body">
            <div class="row g-4">
                <div class="col-12 col-md-6">
                    <label class="form-label" for="phone-number">Phone number</label>
                    <input class="form-control" id="phone-number" name="phone_number" type="tel" placeholder="+1 555 123 4567" required>
                    <small class="form-text">Your phone will be masked in the UI after authentication.</small>
                </div>
                <div class="col-12 col-md-6">
                    <label class="form-label" for="session-path">Session path</label>
                    <input class="form-control" id="session-path" name="session" type="text" value="{{ session_path }}" readonly>
                </div>
                <div class="col-12 col-md-6">
                    <label class="form-label" for="api-id">API ID</label>
                    <input class="form-control" id="api-id" name="api_id" type="number" placeholder="123456">
                </div>
                <div class="col-12 col-md-6">
                    <label class="form-label" for="api-hash">API Hash</label>
                    <input class="form-control" id="api-hash" name="api_hash" type="password" placeholder="0123abcd..." autocomplete="off">
                </div>
                <div class="col-12">
                    <label class="form-label" for="connected-chats">Connected chats</label>
                    <textarea class="form-control" id="connected-chats" rows="3" readonly>{% for channel in channels %}{{ channel.name }}
{% endfor %}</textarea>
                    <small class="form-text">Read-only view of channels configured in tgsentinel.yml.</small>
                </div>
            </div>
        </div>
    </section>

    <section class="card" aria-labelledby="alerts-settings-heading">
        <div class="card-header d-flex justify-content-between align-items-center" style="cursor: pointer;" data-bs-toggle="collapse" data-bs-target="#alerts-settings-body" aria-expanded="false" aria-controls="alerts-settings-body">
            <div>
                <h2 class="card-title mb-0" id="alerts-settings-heading">
                    <i class="bi bi-chevron-right collapse-icon me-2"></i>
                    Alerts & Notifications
                </h2>
                <small class="text-muted">Configure alert destinations and delivery</small>
            </div>
            <button class="btn btn-primary btn-sm" type="button" id="btn-save-alerts" onclick="event.stopPropagation();">
                <span aria-hidden="true">âœ“</span> Apply Changes
            </button>
        </div>
        <div class="collapse card-body" id="alerts-settings-body">
            <div class="row g-4">
                <div class="col-12 col-md-4">
                    <label class="form-label" for="alert-mode">Alert mode</label>
                    <select class="form-select" id="alert-mode" name="mode">
                        <option value="dm">Direct message</option>
                        <option value="channel">Channel</option>
                        <option value="both">Both</option>
                    </select>
                </div>
                <div class="col-12 col-md-4">
                    <label class="form-label" for="alert-channel">Alert channel</label>
                    <input class="form-control" id="alert-channel" name="target_channel" type="text" placeholder="@sentinel_bot">
                </div>
                <div class="col-12 col-md-4">
                    <label class="form-label" for="digest-frequency">Digest frequency</label>
                    <select class="form-select" id="digest-frequency" name="digest">
                        <option value="none">None</option>
                        <option value="hourly" selected>Hourly</option>
                        <option value="daily">Daily</option>
                        <option value="both">Both</option>
                    </select>
                </div>
                <div class="col-12 col-md-4">
                    <label class="form-label" for="digest-top">Digest top N</label>
                    <input class="form-control" id="digest-top" name="digest_top" type="number" min="1" max="100" value="10">
                </div>
                <div class="col-12 col-md-4">
                    <label class="form-label" for="dedupe-window">Deduplication window (minutes)</label>
                    <input class="form-control" id="dedupe-window" name="dedupe_window" type="number" min="0" value="15">
                </div>
                <div class="col-12 col-md-4">
                    <label class="form-label" for="rate-limit">Rate limit per channel (per hour)</label>
                    <input class="form-control" id="rate-limit" name="rate_limit_per_channel" type="number" min="0" value="20">
                </div>
                <div class="col-12">
                    <label class="form-label" for="alert-template">Alert template</label>
                    <textarea class="form-control" id="alert-template" name="template" rows="4" placeholder="[{chat}] {sender}: {excerpt}"></textarea>
                    <small class="form-text">Use placeholders {chat}, {sender}, {excerpt}.</small>
                </div>
            </div>
        </div>
    </section>

    <section class="card" aria-labelledby="scoring-settings-heading">
        <div class="card-header d-flex justify-content-between align-items-center" style="cursor: pointer;" data-bs-toggle="collapse" data-bs-target="#scoring-settings-body" aria-expanded="false" aria-controls="scoring-settings-body">
            <div>
                <h2 class="card-title mb-0" id="scoring-settings-heading">
                    <i class="bi bi-chevron-right collapse-icon me-2"></i>
                    Importance & Scoring
                </h2>
                <small class="text-muted">Tune relevance thresholds and heuristics</small>
            </div>
            <button class="btn btn-primary btn-sm" type="button" id="btn-save-scoring" onclick="event.stopPropagation();">
                <span aria-hidden="true">âœ“</span> Apply Changes
            </button>
        </div>
        <div class="collapse card-body" id="scoring-settings-body">
            <div class="row g-4">
                <div class="col-12 col-md-4">
                    <label class="form-label" for="embedding-model">
                        Embedding model
                        <i class="bi bi-info-circle-fill ms-1 info-tooltip-icon" data-bs-toggle="tooltip" data-bs-placement="top" 
                           data-bs-title="The AI model used to convert text into numerical vectors for semantic similarity matching. MiniLM is fast and efficient, BGE is more accurate."></i>
                    </label>
                    <select class="form-select" id="embedding-model" name="embedding_model">
                        <option value="all-MiniLM-L6-v2">all-MiniLM-L6-v2</option>
                        <option value="bge-small-en">bge-small-en</option>
                        <option value="custom">Custom</option>
                    </select>
                </div>
                <div class="col-12 col-md-4">
                    <label class="form-label" for="similarity-threshold">
                        Similarity threshold
                        <i class="bi bi-info-circle-fill ms-1 info-tooltip-icon" data-bs-toggle="tooltip" data-bs-placement="top" 
                           data-bs-title="Minimum similarity score (0-1) for messages to match your interests. Lower = more messages, higher = only very relevant messages."></i>
                    </label>
                    <input class="form-range" id="similarity-threshold" name="similarity_threshold" type="range" min="0" max="1" step="0.01" value="{{ summary.avg_importance | default(0.42) }}">
                    <p class="text-muted small mb-0">Current: <span id="similarity-value">{{ summary.avg_importance | default(0.42) }}</span></p>
                </div>
                <div class="col-12 col-md-4">
                    <label class="form-label" for="decay-window">
                        Decay window (hours)
                        <i class="bi bi-info-circle-fill ms-1 info-tooltip-icon" data-bs-toggle="tooltip" data-bs-placement="top" 
                           data-bs-title="Time window for message importance to decay. Messages lose relevance over time to prevent alert fatigue on old topics."></i>
                    </label>
                    <input class="form-control" id="decay-window" name="decay_window" type="number" min="1" value="24">
                </div>
                <div class="col-12">
                    <label class="form-label" for="interest-profiles">
                        Interest profiles
                        <i class="bi bi-info-circle-fill ms-1 info-tooltip-icon" data-bs-toggle="tooltip" data-bs-placement="top" 
                           data-bs-title="Keywords or topics you're interested in. The semantic matcher uses these to identify relevant messages (e.g., 'security, vulnerability, zero-day')."></i>
                    </label>
                    <input class="form-control" id="interest-profiles" type="text" value="{{ interests | join(', ') }}" placeholder="comma,separated,topics">
                    <small class="form-text">These inform the semantic matcher.</small>
                </div>
                <div class="col-12">
                    <div class="form-label" id="heuristic-weighting-label">
                        Heuristic weighting
                        <i class="bi bi-info-circle-fill ms-1 info-tooltip-icon" data-bs-toggle="tooltip" data-bs-placement="top" 
                           data-bs-title="Weight (0-1) for each detection heuristic. Higher weights make that signal more important in the final score. Adjust based on what matters most to you."></i>
                    </div>
                    <div class="row g-3" id="heuristic-weighting" aria-labelledby="heuristic-weighting-label">
                        {%- for item in heuristic_options %}
                        <div class="col-12 col-md-4">
                            <label class="form-label" for="weight-{{ loop.index0 }}">{{ item }}</label>
                            <input class="form-range" id="weight-{{ loop.index0 }}" name="weight_{{ loop.index0 }}" type="range" min="0" max="1" step="0.05" value="0.5">
                        </div>
                        {%- endfor %}
                    </div>
                </div>
                <div class="col-12 col-md-4">
                    <div class="form-check form-switch mt-4">
                        <input class="form-check-input" id="feedback-learning" name="feedback_learning" type="checkbox" checked>
                        <label class="form-check-label" for="feedback-learning">
                            Feedback learning
                            <i class="bi bi-info-circle-fill ms-1 info-tooltip-icon" data-bs-toggle="tooltip" data-bs-placement="top" 
                               data-bs-title="When enabled, the system learns from your feedback (ðŸ‘/ðŸ‘Ž) to improve future alert accuracy."></i>
                        </label>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <section class="card" aria-labelledby="channel-management-heading">
        <div class="card-header d-flex justify-content-between align-items-center" style="cursor: pointer;" data-bs-toggle="collapse" data-bs-target="#channel-management-body" aria-expanded="false" aria-controls="channel-management-body">
            <div>
                <h2 class="card-title mb-0" id="channel-management-heading">
                    <i class="bi bi-chevron-right collapse-icon me-2"></i>
                    Channels Management
                </h2>
                <small class="text-muted">Manage channels, rules, and exports</small>
            </div>
            <div class="d-flex gap-2">
                <button class="btn btn-primary btn-sm" type="button" id="btn-add-channels" data-bs-toggle="modal" data-bs-target="#addChannelsModal" onclick="event.stopPropagation();">
                    <span aria-hidden="true">+</span> ADD
                </button>
                <button class="btn btn-outline-primary btn-sm" type="button" id="btn-test-rules" onclick="event.stopPropagation();">Test rules</button>
                <button class="btn btn-outline-primary btn-sm" type="button" id="btn-reset-stats" onclick="event.stopPropagation();">Reset stats</button>
                <button class="btn btn-outline-primary btn-sm" type="button" id="btn-export-yaml" onclick="event.stopPropagation();">Export YAML</button>
            </div>
        </div>
        <div class="collapse card-body table-responsive" id="channel-management-body">
            <table class="table align-middle mb-0" id="channels-table">
                <thead>
                    <tr>
                        <th scope="col">Chat ID</th>
                        <th scope="col">Name</th>
                        <th scope="col">VIP Senders</th>
                        <th scope="col">Keywords</th>
                        <th scope="col">Reaction threshold</th>
                        <th scope="col">Reply threshold</th>
                        <th scope="col">Rate limit/hr</th>
                        <th scope="col">Enabled</th>
                        <th scope="col">Actions</th>
                    </tr>
                </thead>
                <tbody>
                    {%- for channel in channels %}
                    <tr>
                        <td>
                            <button type="button" class="btn btn-sm {% if channel.chat_id < 0 %}btn-info{% else %}btn-primary{% endif %} copy-chat-id" 
                                    data-chat-id="{{ channel.chat_id }}" 
                                    title="Copy {{ channel.chat_id }}">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16">
                                    <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1z"/>
                                    <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0z"/>
                                </svg>
                            </button>
                        </td>
                        <td>{{ channel.name }}</td>
                        <td>{{ channel.vip_senders | join(', ') }}</td>
                        <td>{{ channel.keywords | join(', ') }}</td>
                        <td>{{ channel.reaction_threshold }}</td>
                        <td>{{ channel.reply_threshold }}</td>
                        <td>{{ channel.rate_limit }}</td>
                        <td>
                            <div class="form-check form-switch mb-0">
                                <input class="form-check-input" name="channel_enabled_{{ loop.index0 }}" type="checkbox" id="channel-enabled-{{ loop.index0 }}" checked>
                                <label class="form-check-label visually-hidden" for="channel-enabled-{{ loop.index0 }}">Toggle {{ channel.name }}</label>
                            </div>
                        </td>
                        <td>
                            <button type="button" class="btn btn-sm btn-outline-danger delete-channel" 
                                    data-chat-id="{{ channel.chat_id }}" 
                                    data-chat-name="{{ channel.name }}"
                                    title="Delete Channel">
                                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" class="bi bi-trash" viewBox="0 0 16 16">
                                    <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0z"/>
                                    <path d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4zM2.5 3h11V2h-11z"/>
                                </svg>
                            </button>
                        </td>
                    </tr>
                    {%- else %}
                    <tr>
                        <td colspan="9" class="text-center text-muted">No channels configured yet.</td>
                    </tr>
                    {%- endfor %}
                </tbody>
            </table>
        </div>
    </section>

    <section class="card" aria-labelledby="system-settings-heading">
        <div class="card-header d-flex justify-content-between align-items-center" style="cursor: pointer;" data-bs-toggle="collapse" data-bs-target="#system-settings-body" aria-expanded="false" aria-controls="system-settings-body">
            <div>
                <h2 class="card-title mb-0" id="system-settings-heading">
                    <i class="bi bi-chevron-right collapse-icon me-2"></i>
                    System Settings
                </h2>
                <small class="text-muted">Infrastructure and runtime options</small>
            </div>
        </div>
        <div class="collapse card-body" id="system-settings-body">
            <div class="row g-4">
                <div class="col-12 col-md-4">
                    <label class="form-label" for="redis-host">Redis host</label>
                    <input class="form-control" id="redis-host" name="redis_host" type="text" placeholder="localhost">
                </div>
                <div class="col-12 col-md-4">
                    <label class="form-label" for="redis-port">Redis port</label>
                    <input class="form-control" id="redis-port" name="redis_port" type="number" min="0" max="65535" placeholder="6379">
                </div>
                <div class="col-12 col-md-4">
                    <label class="form-label" for="database-uri">Database URI</label>
                    <input class="form-control" id="database-uri" name="database_uri" type="text" placeholder="sqlite:///data/sentinel.db">
                </div>
                <div class="col-12 col-md-4">
                    <label class="form-label" for="retention-days">Retention (days)</label>
                    <input class="form-control" id="retention-days" name="retention_days" type="number" min="1" value="30">
                </div>
                <div class="col-12 col-md-4">
                    <label class="form-label" for="metrics-endpoint">Metrics endpoint</label>
                    <input class="form-control" id="metrics-endpoint" name="metrics_endpoint" type="text" placeholder="http://localhost:9100/metrics">
                </div>
                <div class="col-12 col-md-4">
                    <label class="form-label" for="logging-level">Logging level</label>
                    <select class="form-select" id="logging-level" name="logging_level">
                        <option value="info">Info</option>
                        <option value="debug">Debug</option>
                        <option value="warn">Warn</option>
                        <option value="error">Error</option>
                    </select>
                </div>
                <div class="col-12 col-md-4">
                    <div class="form-check form-switch mt-4">
                        <input class="form-check-input" id="auto-restart" name="auto_restart" type="checkbox">
                        <label class="form-check-label" for="auto-restart">Auto-restart on fail</label>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <div class="d-flex justify-content-end gap-3">
        <button class="btn btn-reset" type="reset">Reset changes</button>
        <button class="btn btn-danger" type="button" id="btn-clean-db">
            <i class="bi bi-trash3"></i> Clean DB
        </button>
        <button class="btn btn-primary" type="submit" id="btn-save-config">Save configuration</button>
    </div>
</form>

<!-- Add Channels & Users Modal with Tabs -->
<div class="modal fade" id="addChannelsModal" tabindex="-1" aria-labelledby="addChannelsModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="addChannelsModalLabel">Add Channels & Users to Configuration</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <!-- Tabs Navigation -->
                <ul class="nav nav-tabs mb-3" id="addConfigTabs" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="channels-tab" data-bs-toggle="tab" data-bs-target="#channels-tab-pane" type="button" role="tab" aria-controls="channels-tab-pane" aria-selected="true">
                            <i class="bi bi-megaphone me-1"></i>Channels
                        </button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="users-tab" data-bs-toggle="tab" data-bs-target="#users-tab-pane" type="button" role="tab" aria-controls="users-tab-pane" aria-selected="false">
                            <i class="bi bi-person me-1"></i>Private Users
                        </button>
                    </li>
                </ul>

                <!-- Tabs Content -->
                <div class="tab-content" id="addConfigTabsContent">
                    <!-- Channels Tab -->
                    <div class="tab-pane fade show active" id="channels-tab-pane" role="tabpanel" aria-labelledby="channels-tab" tabindex="0">
                        <div id="channels-loading" class="text-center py-4">
                            <div class="spinner-border text-primary" role="status">
                                <span class="visually-hidden">Loading channels...</span>
                            </div>
                            <p class="mt-2 text-muted">Fetching your Telegram channels...</p>
                        </div>
                        <div id="channels-error" class="alert alert-danger d-none" role="alert"></div>
                        <div id="channels-list" class="d-none">
                            <!-- Search Filter -->
                            <div class="mb-3">
                                <input type="text" class="form-control" id="channels-search" placeholder="ðŸ” Search channels by name...">
                            </div>
                            <div class="d-flex justify-content-between align-items-center mb-3">
                                <p class="text-muted mb-0">Select channels to add to your configuration:</p>
                                <button type="button" class="btn btn-sm btn-outline-primary" id="btn-select-all-channels">
                                    <i class="bi bi-check-square me-1"></i>Select All
                                </button>
                            </div>
                            <div class="list-group" id="channels-checkboxes" style="max-height: 400px; overflow-y: auto;">
                                <!-- Channels will be populated here -->
                            </div>
                            <p class="text-muted small mt-3">Selected channels will be added with default settings (reaction threshold: 5, reply threshold: 3).</p>
                        </div>
                    </div>

                    <!-- Users Tab -->
                    <div class="tab-pane fade" id="users-tab-pane" role="tabpanel" aria-labelledby="users-tab" tabindex="0">
                        <div id="users-loading" class="text-center py-4">
                            <div class="spinner-border text-primary" role="status">
                                <span class="visually-hidden">Loading users...</span>
                            </div>
                            <p class="mt-2 text-muted">Fetching your Telegram private chats...</p>
                        </div>
                        <div id="users-error" class="alert alert-danger d-none" role="alert"></div>
                        <div id="users-list" class="d-none">
                            <!-- Search Filter -->
                            <div class="mb-3">
                                <input type="text" class="form-control" id="users-search" placeholder="ðŸ” Search users by name or username...">
                            </div>
                            <div class="d-flex justify-content-between align-items-center mb-3">
                                <p class="text-muted mb-0">Select users to monitor:</p>
                                <button type="button" class="btn btn-sm btn-outline-primary" id="btn-select-all-users">
                                    <i class="bi bi-check-square me-1"></i>Select All
                                </button>
                            </div>
                            <div class="list-group" id="users-checkboxes" style="max-height: 400px; overflow-y: auto;">
                                <!-- Users will be populated here -->
                            </div>
                            <p class="text-muted small mt-3">Only messages from selected users will be monitored.</p>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="btn-add-selected-channels" disabled>Apply Changes</button>
                <button type="button" class="btn btn-primary d-none" id="btn-add-selected-users" disabled>Apply Changes</button>
            </div>
        </div>
    </div>
</div>

{% endblock %}

{% block extra_styles %}
<style>
    /* Collapse icon animation */
    .collapse-icon {
        transition: transform 0.2s ease-in-out;
        display: inline-block;
    }
    
    [aria-expanded="true"] .collapse-icon {
        transform: rotate(90deg);
    }
    
    /* Make card headers look clickable */
    .card-header[data-bs-toggle="collapse"] {
        user-select: none;
    }
    
    .card-header[data-bs-toggle="collapse"]:hover {
        background-color: rgba(var(--bs-primary-rgb), 0.05);
    }
</style>
{% endblock %}

{% block extra_scripts %}
<script>
    const form = document.getElementById("config-form");
    const saveEndpoint = "{{ url_for('api_config_save') }}";

    function collectPayload() {
        const payload = {};
        
        // Collect all text/number inputs from FormData as baseline
        const formData = new FormData(form);
        formData.forEach((value, key) => {
            payload[key] = value;
        });
        
        // Explicitly read and convert heuristic weight sliders to Numbers
        for (let i = 0; i < 5; i++) {
            const weightInput = document.getElementById(`weight-${i}`);
            if (weightInput) {
                payload[`weight_${i}`] = Number(weightInput.value);
            }
        }
        
        // Explicitly read all checkboxes and convert to Boolean
        form.querySelectorAll("input[type='checkbox'][name]").forEach((checkbox) => {
            if (checkbox instanceof HTMLInputElement) {
                payload[checkbox.name] = checkbox.checked;
            }
        });
        
        // Parse interests as array
        payload.interests = (document.getElementById("interest-profiles").value || "")
            .split(",")
            .map((item) => item.trim())
            .filter(Boolean);
        
        // Ensure similarity_threshold is Number
        const similarityInput = document.getElementById("similarity-threshold");
        if (similarityInput) {
            payload.similarity_threshold = Number(similarityInput.value || 0.42);
        }
        
        // Convert numeric fields to Number
        const numericFields = ['decay_window', 'redis_port', 'log_retention_days'];
        numericFields.forEach((field) => {
            if (payload[field] !== undefined) {
                payload[field] = Number(payload[field]);
            }
        });
        
        return payload;
    }

    let isSubmitting = false;

    async function submitConfig(event) {
        event.preventDefault();
        
        // Guard against double submits
        if (isSubmitting) {
            console.warn("Configuration save already in progress, ignoring duplicate submit");
            return;
        }
        
        const submitButton = document.getElementById("btn-save-config");
        const originalButtonText = submitButton ? submitButton.textContent : "";
        
        try {
            // Mark as submitting and disable button
            isSubmitting = true;
            
            if (submitButton) {
                submitButton.disabled = true;
                submitButton.setAttribute("aria-busy", "true");
                submitButton.setAttribute("aria-disabled", "true");
                submitButton.textContent = "Saving...";
                submitButton.classList.add("loading");
            }
            
            const payload = collectPayload();
            const response = await fetch(saveEndpoint, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
            });
            
            if (!response.ok) {
                throw new Error("Persist failed");
            }
            
            showToast("Configuration saved", "success");
            
            // Restart sentinel container to apply changes
            try {
                const restartResponse = await fetch("{{ url_for('api_restart_sentinel') }}", {
                    method: "POST",
                });
                
                if (restartResponse.ok) {
                    showToast("Sentinel container is restarting to apply changes...", "info");
                } else {
                    showToast("Configuration saved but sentinel restart failed. Manual restart recommended.", "warning");
                }
            } catch (restartError) {
                console.error("Restart error:", restartError);
                showToast("Configuration saved but sentinel restart failed. Manual restart recommended.", "warning");
            }
        } catch (error) {
            console.error(error);
            showToast("Could not save configuration", "error");
        } finally {
            // Always restore button state
            isSubmitting = false;
            
            if (submitButton) {
                submitButton.disabled = false;
                submitButton.removeAttribute("aria-busy");
                submitButton.removeAttribute("aria-disabled");
                submitButton.textContent = originalButtonText;
                submitButton.classList.remove("loading");
            }
        }
    }

    document.addEventListener("DOMContentLoaded", () => {
        // Load current configuration
        loadCurrentConfig();
        
        document.getElementById("similarity-threshold")?.addEventListener("input", (event) => {
            document.getElementById("similarity-value").textContent = Number(event.target.value).toFixed(2);
        });
        document.getElementById("btn-reauth")?.addEventListener("click", () => {
            showToast("Reauthentication initiated. Monitor logs for instructions.", "info");
        });
        // TEST RULES: call backend and show a concise summary
        document.getElementById("btn-test-rules")?.addEventListener("click", async () => {
            try {
                const resp = await fetch("/api/config/rules/test", { method: "POST", headers: {"Content-Type": "application/json"}, body: JSON.stringify({}) });
                const data = await resp.json();
                if (!resp.ok) throw new Error(data && data.message ? data.message : `HTTP ${resp.status}`);
                const tested = data?.tested ?? 0;
                showToast(`Rules tested for ${tested} channel(s)`, "success");
            } catch (e) {
                console.error("Rules test error", e);
                showToast("Failed to test rules", "error");
            }
        });
        // RESET STATS: best-effort clear of transient counters
        document.getElementById("btn-reset-stats")?.addEventListener("click", async () => {
            try {
                const resp = await fetch("/api/config/stats/reset", { method: "POST" });
                if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                showToast("Channel statistics reset", "warning");
            } catch (e) {
                console.error("Reset stats error", e);
                showToast("Failed to reset stats", "error");
            }
        });
        // EXPORT YAML: trigger file download
        document.getElementById("btn-export-yaml")?.addEventListener("click", async () => {
            try {
                const url = "/api/config/export";
                // Open in a new tab to prompt download using browser defaults
                window.open(url, "_blank");
                showToast("Exporting YAML", "info");
            } catch (e) {
                console.error("Export YAML error", e);
                showToast("Failed to export YAML", "error");
            }
        });
        form?.addEventListener("submit", submitConfig);
        
        // Initialize Bootstrap tooltips
        const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]');
        const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl));
        
        // Handle Save Scoring button
        document.getElementById("btn-save-scoring")?.addEventListener("click", async () => {
            const button = document.getElementById("btn-save-scoring");
            const originalText = button.innerHTML;
            
            try {
                button.disabled = true;
                button.innerHTML = '<span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span> Applying...';
                
                const payload = collectPayload();
                const response = await fetch(saveEndpoint, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(payload),
                });
                
                if (!response.ok) {
                    throw new Error("Save failed");
                }
                
                showToast("Settings saved successfully", "success");
                
                // Restart sentinel container
                try {
                    const restartResponse = await fetch("{{ url_for('api_restart_sentinel') }}", {
                        method: "POST",
                    });
                    
                    if (restartResponse.ok) {
                        showToast("Sentinel container is restarting...", "info");
                    } else {
                        showToast("Settings saved but sentinel restart failed. Restart manually.", "warning");
                    }
                } catch (restartError) {
                    console.error("Restart error:", restartError);
                    showToast("Settings saved but sentinel restart failed. Restart manually.", "warning");
                }
                
            } catch (error) {
                console.error(error);
                showToast("Failed to save settings", "error");
            } finally {
                button.disabled = false;
                button.innerHTML = originalText;
            }
        });
        
        // Handle Save Alerts button
        document.getElementById("btn-save-alerts")?.addEventListener("click", async () => {
            const button = document.getElementById("btn-save-alerts");
            const originalText = button.innerHTML;
            
            try {
                button.disabled = true;
                button.innerHTML = '<span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span> Applying...';
                
                const payload = collectPayload();
                const response = await fetch(saveEndpoint, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(payload),
                });
                
                if (!response.ok) {
                    throw new Error("Save failed");
                }
                
                showToast("Settings saved successfully", "success");
                
                // Restart sentinel container
                try {
                    const restartResponse = await fetch("{{ url_for('api_restart_sentinel') }}", {
                        method: "POST",
                    });
                    
                    if (restartResponse.ok) {
                        showToast("Sentinel container is restarting...", "info");
                    } else {
                        showToast("Settings saved but sentinel restart failed. Restart manually.", "warning");
                    }
                } catch (restartError) {
                    console.error("Restart error:", restartError);
                    showToast("Settings saved but sentinel restart failed. Restart manually.", "warning");
                }
                
            } catch (error) {
                console.error(error);
                showToast("Failed to save settings", "error");
            } finally {
                button.disabled = false;
                button.innerHTML = originalText;
            }
        });
    });
    
    async function loadCurrentConfig() {
        try {
            const response = await fetch("{{ url_for('api_config_current') }}");
            if (!response.ok) {
                throw new Error("Failed to load configuration");
            }
            
            const config = await response.json();
            
            // Populate Telegram Account fields
            if (config.telegram) {
                const apiIdInput = document.getElementById("api-id");
                const apiHashInput = document.getElementById("api-hash");
                const phoneInput = document.getElementById("phone-number");
                
                if (apiIdInput && config.telegram.api_id) {
                    apiIdInput.value = config.telegram.api_id;
                }
                if (apiHashInput && config.telegram.api_hash) {
                    apiHashInput.value = config.telegram.api_hash;
                }
                if (phoneInput && config.telegram.phone_number) {
                    phoneInput.value = config.telegram.phone_number;
                }
            }
            
            // Populate Alerts & Notifications fields
            if (config.alerts) {
                const alertModeSelect = document.getElementById("alert-mode");
                const alertChannelInput = document.getElementById("alert-channel");
                
                if (alertModeSelect && config.alerts.mode) {
                    alertModeSelect.value = config.alerts.mode;
                }
                if (alertChannelInput && config.alerts.target_channel) {
                    alertChannelInput.value = config.alerts.target_channel;
                }
            }
            
            // Populate Digest fields
            if (config.digest) {
                const digestTopInput = document.getElementById("digest-top");
                
                if (digestTopInput && config.digest.top_n) {
                    digestTopInput.value = config.digest.top_n;
                }
                
                // Set digest frequency based on hourly/daily flags
                const digestFrequencySelect = document.getElementById("digest-frequency");
                if (digestFrequencySelect) {
                    // Default to hourly if config.digest doesn't exist or both are false
                    if (!config.digest) {
                        digestFrequencySelect.value = "hourly";
                    } else if (config.digest.hourly && config.digest.daily) {
                        digestFrequencySelect.value = "both";
                    } else if (config.digest.hourly) {
                        digestFrequencySelect.value = "hourly";
                    } else if (config.digest.daily) {
                        digestFrequencySelect.value = "daily";
                    } else {
                        // Default to hourly instead of none
                        digestFrequencySelect.value = "hourly";
                    }
                }
            }
            
            // Populate Redis fields
            if (config.redis) {
                const redisHostInput = document.getElementById("redis-host");
                const redisPortInput = document.getElementById("redis-port");
                
                if (redisHostInput && config.redis.host) {
                    redisHostInput.value = config.redis.host;
                }
                if (redisPortInput && config.redis.port) {
                    redisPortInput.value = config.redis.port;
                }
            }
            
            // Populate Semantic fields
            if (config.semantic) {
                const embeddingsModelInput = document.getElementById("embeddings-model");
                const similarityThresholdInput = document.getElementById("similarity-threshold");
                const similarityValueSpan = document.getElementById("similarity-value");
                
                if (embeddingsModelInput && config.semantic.embeddings_model) {
                    embeddingsModelInput.value = config.semantic.embeddings_model;
                }
                if (similarityThresholdInput && config.semantic.similarity_threshold !== undefined) {
                    similarityThresholdInput.value = config.semantic.similarity_threshold;
                    if (similarityValueSpan) {
                        similarityValueSpan.textContent = config.semantic.similarity_threshold.toFixed(2);
                    }
                }
            }
            
            // Populate Database URI
            if (config.database_uri) {
                const databaseUriInput = document.getElementById("database-uri");
                if (databaseUriInput) {
                    databaseUriInput.value = config.database_uri;
                }
            }
            
        } catch (error) {
            console.error("Failed to load configuration:", error);
            showToast("Could not load current configuration", "error");
        }
    }
    
    // Handle Add Channels Modal
    let availableChats = [];
    let existingChannelIds = new Set();
    
    // Handle Add Users Modal (global variables)
    let availableUsers = [];
    let existingUserIds = new Set();
    let usersDataLoaded = false; // Track if users have been loaded
    
    document.addEventListener("DOMContentLoaded", () => {
        const addChannelsModal = document.getElementById("addChannelsModal");
        
        // Handle tab switching to show/hide appropriate "Add Selected" button
        const channelsTab = document.getElementById("channels-tab");
        const usersTab = document.getElementById("users-tab");
        const btnAddSelectedChannels = document.getElementById("btn-add-selected-channels");
        const btnAddSelectedUsers = document.getElementById("btn-add-selected-users");
        
        if (channelsTab && usersTab) {
            channelsTab.addEventListener("shown.bs.tab", () => {
                btnAddSelectedChannels.classList.remove("d-none");
                btnAddSelectedUsers.classList.add("d-none");
            });
            
            usersTab.addEventListener("shown.bs.tab", async () => {
                btnAddSelectedChannels.classList.add("d-none");
                btnAddSelectedUsers.classList.remove("d-none");
                
                // Always reset error state when showing tab
                document.getElementById("users-error").classList.add("d-none");
                
                // Load users when tab is shown
                await loadUsersData();
            });
        }
        
        if (addChannelsModal) {
            // Apply glass backdrop effect
            const addGlassClass = () => {
                setTimeout(() => {
                    const backdrop = document.querySelector('.modal-backdrop');
                    if (backdrop && !backdrop.classList.contains('glass-backdrop')) {
                        backdrop.classList.add('glass-backdrop');
                    }
                }, 50);
            };
            
            addChannelsModal.addEventListener('shown.bs.modal', addGlassClass);
            addChannelsModal.addEventListener('show.bs.modal', addGlassClass);
            
            // On hide, blur focused element inside to prevent aria-hidden focus conflicts
            addChannelsModal.addEventListener("hide.bs.modal", () => {
                if (document.activeElement && addChannelsModal.contains(document.activeElement)) {
                    document.activeElement.blur();
                }
                // Reset users data loaded flag so it reloads next time
                usersDataLoaded = false;
            });

            addChannelsModal.addEventListener("show.bs.modal", async () => {
                // Reset modal state - show channels tab by default
                btnAddSelectedChannels.classList.remove("d-none");
                btnAddSelectedUsers.classList.add("d-none");
                
                document.getElementById("channels-loading").classList.remove("d-none");
                document.getElementById("channels-error").classList.add("d-none");
                document.getElementById("channels-list").classList.add("d-none");
                document.getElementById("btn-add-selected-channels").disabled = true;
                
                // Get existing channel IDs
                try {
                    const configResponse = await fetch("{{ url_for('api_config_current') }}");
                    if (configResponse.ok) {
                        const configData = await configResponse.json();
                        existingChannelIds = new Set((configData.channels || []).map(c => c.id));
                    }
                } catch (err) {
                    console.error("Failed to load existing channels:", err);
                }
                
                try {
                    const response = await fetch("{{ url_for('api_telegram_chats') }}");
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.message || "Failed to fetch channels");
                    }
                    
                    const data = await response.json();
                    availableChats = data.chats || [];
                    
                    if (availableChats.length === 0) {
                        throw new Error("No channels found. Make sure you have joined some channels or groups.");
                    }
                    
                    // Populate checkboxes
                    renderChannelCheckboxes(availableChats, existingChannelIds);
                    
                    // Initialize button state based on pre-selections
                    updateApplyButtonState();
                    
                    document.getElementById("channels-loading").classList.add("d-none");
                    document.getElementById("channels-list").classList.remove("d-none");
                    
                } catch (error) {
                    console.error("Failed to load channels:", error);
                    document.getElementById("channels-loading").classList.add("d-none");
                    const errorDiv = document.getElementById("channels-error");
                    errorDiv.textContent = error.message || "Could not load channels from Telegram";
                    errorDiv.classList.remove("d-none");
                }
            });
        }
        
        // Helper function to update "Apply Changes" button state based on checkbox selections
        function updateApplyButtonState() {
            const checkboxes = document.querySelectorAll("#channels-checkboxes input[type='checkbox']");
            let hasChanges = false;
            checkboxes.forEach(cb => {
                const isExisting = cb.dataset.existing === "true";
                const isChecked = cb.checked;
                // Change detected if: (existing and unchecked) OR (new and checked)
                if ((isExisting && !isChecked) || (!isExisting && isChecked)) {
                    hasChanges = true;
                }
            });
            const btn = document.getElementById("btn-add-selected-channels");
            if (btn) {
                btn.disabled = !hasChanges;
            }
        }
        
        // Handle checkbox changes
        document.getElementById("channels-checkboxes")?.addEventListener("change", () => {
            updateApplyButtonState();
        });
        
        // Handle add/remove selected channels
        document.getElementById("btn-add-selected-channels")?.addEventListener("click", async () => {
            const checkboxes = document.querySelectorAll("#channels-checkboxes input[type='checkbox']");
            
            // Collect channels to add (new ones that are checked)
            const toAdd = [];
            // Collect channels to remove (existing ones that are unchecked)
            const toRemove = [];
            
            checkboxes.forEach(checkbox => {
                const chatId = parseInt(checkbox.value, 10);
                const chat = availableChats.find(c => c.id === chatId);
                const isExisting = checkbox.dataset.existing === "true";
                const isChecked = checkbox.checked;
                
                if (!isExisting && isChecked && chat) {
                    // New channel being added
                    toAdd.push({ id: chat.id, name: chat.name });
                } else if (isExisting && !isChecked && chat) {
                    // Existing channel being removed
                    toRemove.push({ id: chat.id, name: chat.name });
                }
            });
            
            if (toAdd.length === 0 && toRemove.length === 0) {
                showToast("No changes to apply", "warning");
                return;
            }
            
            try {
                let addedCount = 0;
                let removedCount = 0;
                
                // Add new channels
                if (toAdd.length > 0) {
                    const response = await fetch("{{ url_for('api_config_channels_add') }}", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ channels: toAdd }),
                    });
                    
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.message || "Failed to add channels");
                    }
                    
                    const result = await response.json();
                    addedCount = result.added || 0;
                }
                
                // Remove unchecked channels
                if (toRemove.length > 0) {
                    const deleteEndpointTemplate = "{{ url_for('api_config_channels_delete', chat_id='__CHAT_ID__') }}";
                    for (const channel of toRemove) {
                        const deleteUrl = deleteEndpointTemplate.replace("__CHAT_ID__", encodeURIComponent(channel.id));
                        const response = await fetch(deleteUrl, {
                            method: "DELETE",
                        });

                        if (response.ok) {
                            removedCount++;
                        }
                    }
                }
                
                // Build success message
                const messages = [];
                if (addedCount > 0) messages.push(`Added ${addedCount} channel(s)`);
                if (removedCount > 0) messages.push(`Removed ${removedCount} channel(s)`);
                showToast(messages.join(" and "), "success");
                
                // Close modal
                const modal = bootstrap.Modal.getInstance(document.getElementById("addChannelsModal"));
                if (modal) {
                    modal.hide();
                }
                
                // Reload page to show changes
                setTimeout(() => {
                    window.location.reload();
                }, 1500);
                
            } catch (error) {
                console.error("Failed to update channels:", error);
                showToast(error.message || "Could not update channels", "error");
            }
        });
    });
    
    function renderChannelCheckboxes(chats, existingIds) {
        const container = document.getElementById("channels-checkboxes");
        if (!container) return;
        
        container.innerHTML = "";
        
        // Sort by name
        const sortedChats = [...chats].sort((a, b) => a.name.localeCompare(b.name));
        
        sortedChats.forEach(chat => {
            const div = document.createElement("div");
            div.className = "list-group-item";
            
            const isExisting = existingIds.has(chat.id);
            
            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.className = "form-check-input me-2";
            checkbox.id = `chat-${chat.id}`;
            checkbox.value = chat.id;
            checkbox.checked = isExisting;  // Pre-select existing channels
            checkbox.dataset.existing = isExisting ? "true" : "false";  // Track if existing
            
            const label = document.createElement("label");
            label.className = "form-check-label d-flex justify-content-between align-items-center w-100";
            label.htmlFor = `chat-${chat.id}`;
            label.style.cursor = "pointer";
            
            // Add visual styling for already-configured items
            if (isExisting) {
                div.style.backgroundColor = "rgba(25, 135, 84, 0.1)";  // Light green background
                div.style.borderLeft = "3px solid #198754";  // Green left border
            }
            
            const nameWrapper = document.createElement("div");
            nameWrapper.className = "d-flex align-items-center gap-2";
            
            const nameSpan = document.createElement("span");
            nameSpan.textContent = chat.name;
            
            nameWrapper.appendChild(nameSpan);
            
            if (isExisting) {
                const checkmark = document.createElement("span");
                checkmark.className = "badge bg-success";
                checkmark.innerHTML = '<i class="bi bi-check-circle me-1"></i>Monitored';
                checkmark.title = "Uncheck to remove from monitoring";
                nameWrapper.appendChild(checkmark);
            }
            
            const badgeSpan = document.createElement("span");
            badgeSpan.className = `badge bg-${chat.type === 'channel' ? 'primary' : chat.type === 'supergroup' ? 'info' : 'secondary'}`;
            badgeSpan.textContent = chat.type;
            
            label.appendChild(nameWrapper);
            label.appendChild(badgeSpan);
            
            div.appendChild(checkbox);
            div.appendChild(label);
            container.appendChild(div);
        });
    }
    
    // Handle channels search filter
    document.addEventListener("DOMContentLoaded", () => {
        const channelsSearch = document.getElementById("channels-search");
        if (channelsSearch) {
            channelsSearch.addEventListener("input", (e) => {
                const searchTerm = e.target.value.toLowerCase();
                const items = document.querySelectorAll("#channels-checkboxes .list-group-item");
                
                items.forEach(item => {
                    const label = item.querySelector("label");
                    const text = label ? label.textContent.toLowerCase() : "";
                    
                    if (text.includes(searchTerm)) {
                        item.style.display = "";
                    } else {
                        item.style.display = "none";
                    }
                });
            });
        }
    });
    
    // Handle copy chat ID to clipboard
    document.addEventListener("DOMContentLoaded", () => {
        document.body.addEventListener("click", (e) => {
            const copyButton = e.target.closest(".copy-chat-id");
            if (copyButton) {
                const chatId = copyButton.dataset.chatId;
                
                // Use modern clipboard API
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(chatId)
                        .then(() => {
                            // Visual feedback
                            const originalHTML = copyButton.innerHTML;
                            copyButton.innerHTML = `
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-check" viewBox="0 0 16 16">
                                    <path d="M10.97 4.97a.75.75 0 0 1 1.07 1.05l-3.99 4.99a.75.75 0 0 1-1.08.02L4.324 8.384a.75.75 0 1 1 1.06-1.06l2.094 2.093 3.473-4.425z"/>
                                </svg>
                            `;
                            
                            setTimeout(() => {
                                copyButton.innerHTML = originalHTML;
                            }, 2000);
                            
                            showToast(`Chat ID ${chatId} copied to clipboard`, "success");
                        })
                        .catch((err) => {
                            console.error("Failed to copy:", err);
                            showToast("Failed to copy to clipboard", "error");
                        });
                } else {
                    // Fallback for older browsers
                    const textArea = document.createElement("textarea");
                    textArea.value = chatId;
                    textArea.style.position = "fixed";
                    textArea.style.left = "-999999px";
                    document.body.appendChild(textArea);
                    textArea.select();
                    
                    try {
                        document.execCommand("copy");
                        showToast(`Chat ID ${chatId} copied to clipboard`, "success");
                    } catch (err) {
                        console.error("Fallback copy failed:", err);
                        showToast("Failed to copy to clipboard", "error");
                    }
                    
                    document.body.removeChild(textArea);
                }
            }
        });
    });
    
    // Handle delete channel
    document.addEventListener("DOMContentLoaded", () => {
        document.body.addEventListener("click", (e) => {
            const deleteButton = e.target.closest(".delete-channel");
            if (deleteButton) {
                const chatId = deleteButton.dataset.chatId;
                const chatName = deleteButton.dataset.chatName;
                
                // Confirm deletion
                if (confirm(`Are you sure you want to delete "${chatName}" (ID: ${chatId})?\n\nThis will remove the channel from monitoring and reload the sentinel container.`)) {
                    // Disable button during deletion
                    deleteButton.disabled = true;
                    deleteButton.innerHTML = `
                        <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                    `;
                    
                    fetch(`/api/config/channels/${chatId}`, {
                        method: "DELETE",
                    })
                        .then(response => {
                            if (!response.ok) {
                                return response.json().then(data => {
                                    throw new Error(data.message || "Failed to delete channel");
                                });
                            }
                            return response.json();
                        })
                        .then(data => {
                            showToast(`Channel "${chatName}" deleted successfully`, "success");
                            
                            // Reload page to show updated channels
                            setTimeout(() => {
                                window.location.reload();
                            }, 1500);
                        })
                        .catch(error => {
                            console.error("Failed to delete channel:", error);
                            showToast(error.message || "Could not delete channel", "error");
                            
                            // Re-enable button
                            deleteButton.disabled = false;
                            deleteButton.innerHTML = `
                                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" class="bi bi-trash" viewBox="0 0 16 16">
                                    <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0z"/>
                                    <path d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4zM2.5 3h11V2h-11z"/>
                                </svg>
                            `;
                        });
                }
            }
        });
    });
    
    // Handle Select All Channels button
    document.getElementById("btn-select-all-channels")?.addEventListener("click", () => {
        const checkboxes = document.querySelectorAll("#channels-checkboxes input[type='checkbox']");
        const allChecked = Array.from(checkboxes).every(cb => cb.checked);
        
        checkboxes.forEach(cb => {
            cb.checked = !allChecked;
        });
        
        // Trigger change event to update button state
        const event = new Event("change", { bubbles: true });
        document.getElementById("channels-checkboxes").dispatchEvent(event);
        
        // Update button text
        const btn = document.getElementById("btn-select-all-channels");
        btn.innerHTML = allChecked ? 
            '<i class="bi bi-check-square me-1"></i>Select All' : 
            '<i class="bi bi-square me-1"></i>Deselect All';
    });
    
    // Function to load users data (reusable for both modal and tab)
    async function loadUsersData() {
        // Skip if already loaded
        if (usersDataLoaded) {
            return;
        }
        
        // Reset state
        document.getElementById("users-loading").classList.remove("d-none");
        document.getElementById("users-error").classList.add("d-none");
        document.getElementById("users-list").classList.add("d-none");
        document.getElementById("btn-add-selected-users").disabled = true;
        
        // Get existing monitored user IDs
        try {
            const configResponse = await fetch("{{ url_for('api_config_current') }}");
            if (configResponse.ok) {
                const configData = await configResponse.json();
                existingUserIds = new Set((configData.monitored_users || []).map(u => u.id));
            }
        } catch (err) {
            console.error("Failed to load existing users:", err);
        }
        
        try {
            const response = await fetch("{{ url_for('api_telegram_users') }}");
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                const error = new Error(errorData.message || "Failed to fetch users");
                error.status = response.status; // Attach HTTP status code
                throw error;
            }
            
            const data = await response.json();
            availableUsers = data.users || [];
            
            if (availableUsers.length === 0) {
                // Show informational message instead of error
                document.getElementById("users-loading").classList.add("d-none");
                const errorDiv = document.getElementById("users-error");
                errorDiv.className = "alert alert-info"; // Use info style instead of danger
                errorDiv.innerHTML = `
                    <i class="bi bi-info-circle me-2"></i>
                    <strong>No private chats found.</strong><br>
                    Start conversations with users in Telegram to monitor them here.
                `;
                errorDiv.classList.remove("d-none");
                usersDataLoaded = true; // Mark as loaded to prevent reload
                return; // Exit without throwing
            }
            
            // Populate checkboxes
            renderUserCheckboxes(availableUsers, existingUserIds);
            
            document.getElementById("users-loading").classList.add("d-none");
            document.getElementById("users-list").classList.remove("d-none");
            
            usersDataLoaded = true; // Mark as loaded
            
        } catch (error) {
            console.error("Failed to load users:", error);
            document.getElementById("users-loading").classList.add("d-none");
            const errorDiv = document.getElementById("users-error");
            errorDiv.className = "alert alert-danger"; // Use danger style for actual errors
            
            // Check if it's a timeout error (504 Gateway Timeout or AbortError)
            if (error.status === 504 || error.name === "AbortError") {
                errorDiv.innerHTML = `
                    <i class="bi bi-exclamation-triangle me-2"></i>
                    <strong>Connection timeout.</strong><br>
                    Please ensure the Telegram client is connected and running. Try again in a few moments.
                `;
            } else {
                errorDiv.textContent = error.message || "Could not load users from Telegram";
            }
            errorDiv.classList.remove("d-none");
            // Don't mark as loaded on error so user can retry by switching tabs
        }
    }
    
    document.addEventListener("DOMContentLoaded", () => {
        // Handle checkbox changes for users
        document.getElementById("users-checkboxes")?.addEventListener("change", () => {
            // Check if any changes were made (checked non-existing or unchecked existing)
            const checkboxes = document.querySelectorAll("#users-checkboxes input[type='checkbox']");
            let hasChanges = false;
            checkboxes.forEach(cb => {
                const isExisting = cb.dataset.existing === "true";
                const isChecked = cb.checked;
                // Change detected if: (existing and unchecked) OR (new and checked)
                if ((isExisting && !isChecked) || (!isExisting && isChecked)) {
                    hasChanges = true;
                }
            });
            document.getElementById("btn-add-selected-users").disabled = !hasChanges;
        });
        
        // Handle Select All Users button
        document.getElementById("btn-select-all-users")?.addEventListener("click", () => {
            const checkboxes = document.querySelectorAll("#users-checkboxes input[type='checkbox']");
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);
            
            checkboxes.forEach(cb => {
                cb.checked = !allChecked;
            });
            
            // Trigger change event to update button state
            const event = new Event("change", { bubbles: true });
            document.getElementById("users-checkboxes").dispatchEvent(event);
            
            // Update button text
            const btn = document.getElementById("btn-select-all-users");
            btn.innerHTML = allChecked ? 
                '<i class="bi bi-check-square me-1"></i>Select All' : 
                '<i class="bi bi-square me-1"></i>Deselect All';
        });
        
        // Handle add/remove selected users
        document.getElementById("btn-add-selected-users")?.addEventListener("click", async () => {
            const checkboxes = document.querySelectorAll("#users-checkboxes input[type='checkbox']");
            
            // Collect users to add (new ones that are checked)
            const toAdd = [];
            // Collect users to remove (existing ones that are unchecked)
            const toRemove = [];
            
            checkboxes.forEach(checkbox => {
                const userId = parseInt(checkbox.value, 10);
                const user = availableUsers.find(u => u.id === userId);
                const isExisting = checkbox.dataset.existing === "true";
                const isChecked = checkbox.checked;
                
                if (!isExisting && isChecked && user) {
                    // New user being added
                    toAdd.push({ id: user.id, name: user.name, username: user.username || "" });
                } else if (isExisting && !isChecked && user) {
                    // Existing user being removed
                    toRemove.push({ id: user.id, name: user.name });
                }
            });
            
            if (toAdd.length === 0 && toRemove.length === 0) {
                showToast("No changes to apply", "warning");
                return;
            }
            
            try {
                let addedCount = 0;
                let removedCount = 0;
                
                // Add new users
                if (toAdd.length > 0) {
                    const response = await fetch("{{ url_for('api_config_users_add') }}", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ users: toAdd }),
                    });
                    
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.message || "Failed to add users");
                    }
                    
                    const result = await response.json();
                    addedCount = result.added || 0;
                }
                
                // Remove unchecked users
                if (toRemove.length > 0) {
                    const deleteEndpointTemplate = "{{ url_for('api_config_users_delete', user_id='__USER_ID__') }}";
                    for (const user of toRemove) {
                        const deleteUrl = deleteEndpointTemplate.replace("__USER_ID__", encodeURIComponent(user.id));
                        const response = await fetch(deleteUrl, {
                            method: "DELETE",
                        });
                        
                        if (response.ok) {
                            removedCount++;
                        }
                    }
                }
                
                // Build success message
                const messages = [];
                if (addedCount > 0) messages.push(`Added ${addedCount} user(s)`);
                if (removedCount > 0) messages.push(`Removed ${removedCount} user(s)`);
                showToast(messages.join(" and "), "success");
                
                // Close the main Channels/Users modal
                const modal = bootstrap.Modal.getInstance(document.getElementById("addChannelsModal"));
                if (modal) {
                    // Proactively blur any focused element inside to avoid aria-hidden focus conflicts
                    const modalEl = document.getElementById("addChannelsModal");
                    if (document.activeElement && modalEl && modalEl.contains(document.activeElement)) {
                        document.activeElement.blur();
                    }
                    modal.hide();
                }
                
                // Reload page to show new users
                setTimeout(() => {
                    window.location.reload();
                }, 1500);
                
            } catch (error) {
                console.error("Failed to add users:", error);
                showToast(error.message || "Could not add users", "error");
            }
        });
    });
    
    function renderUserCheckboxes(users, existingIds) {
        const container = document.getElementById("users-checkboxes");
        if (!container) return;
        
        container.innerHTML = "";
        
        // Sort by name
        const sortedUsers = [...users].sort((a, b) => a.name.localeCompare(b.name));
        
        sortedUsers.forEach(user => {
            const div = document.createElement("div");
            div.className = "list-group-item";
            
            const isExisting = existingIds.has(user.id);
            
            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.className = "form-check-input me-2";
            checkbox.id = `user-${user.id}`;
            checkbox.value = user.id;
            checkbox.checked = isExisting;  // Pre-select existing users
            checkbox.dataset.existing = isExisting ? "true" : "false";  // Track if existing
            
            const label = document.createElement("label");
            label.className = "form-check-label d-flex justify-content-between align-items-center w-100";
            label.htmlFor = `user-${user.id}`;
            label.style.cursor = "pointer";
            
            // Add visual styling for already-monitored users
            if (isExisting) {
                div.style.backgroundColor = "rgba(25, 135, 84, 0.1)";  // Light green background
                div.style.borderLeft = "3px solid #198754";  // Green left border
            }
            
            const nameWrapper = document.createElement("div");
            nameWrapper.className = "d-flex align-items-center gap-2";
            
            const nameSpan = document.createElement("span");
            nameSpan.textContent = user.name;
            if (user.username) {
                nameSpan.textContent += ` (@${user.username})`;
            }
            
            nameWrapper.appendChild(nameSpan);
            
            if (isExisting) {
                const checkmark = document.createElement("span");
                checkmark.className = "badge bg-success";
                checkmark.innerHTML = '<i class="bi bi-check-circle me-1"></i>Monitored';
                checkmark.title = "Uncheck to remove from monitoring";
                nameWrapper.appendChild(checkmark);
            }
            
            label.appendChild(nameWrapper);
            
            div.appendChild(checkbox);
            div.appendChild(label);
            container.appendChild(div);
        });
    }
    
    // Handle users search filter
    document.addEventListener("DOMContentLoaded", () => {
        const usersSearch = document.getElementById("users-search");
        if (usersSearch) {
            usersSearch.addEventListener("input", (e) => {
                const searchTerm = e.target.value.toLowerCase();
                const items = document.querySelectorAll("#users-checkboxes .list-group-item");
                
                items.forEach(item => {
                    const label = item.querySelector("label");
                    const text = label ? label.textContent.toLowerCase() : "";
                    
                    if (text.includes(searchTerm)) {
                        item.style.display = "";
                    } else {
                        item.style.display = "none";
                    }
                });
            });
        }
    });
    
    // Handle copy user ID to clipboard
    document.addEventListener("DOMContentLoaded", () => {
        document.body.addEventListener("click", (e) => {
            const copyButton = e.target.closest(".copy-user-id");
            if (copyButton) {
                const userId = copyButton.dataset.userId;
                
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(userId)
                        .then(() => {
                            const originalHTML = copyButton.innerHTML;
                            copyButton.innerHTML = `
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-check" viewBox="0 0 16 16">
                                    <path d="M10.97 4.97a.75.75 0 0 1 1.07 1.05l-3.99 4.99a.75.75 0 0 1-1.08.02L4.324 8.384a.75.75 0 1 1 1.06-1.06l2.094 2.093 3.473-4.425z"/>
                                </svg>
                            `;
                            
                            setTimeout(() => {
                                copyButton.innerHTML = originalHTML;
                            }, 2000);
                            
                            showToast(`User ID ${userId} copied to clipboard`, "success");
                        })
                        .catch((err) => {
                            console.error("Failed to copy:", err);
                            showToast("Failed to copy to clipboard", "error");
                        });
                } else {
                    const textArea = document.createElement("textarea");
                    textArea.value = userId;
                    textArea.style.position = "fixed";
                    textArea.style.left = "-999999px";
                    document.body.appendChild(textArea);
                    textArea.select();
                    
                    try {
                        document.execCommand("copy");
                        showToast(`User ID ${userId} copied to clipboard`, "success");
                    } catch (err) {
                        console.error("Fallback copy failed:", err);
                        showToast("Failed to copy to clipboard", "error");
                    }
                    
                    document.body.removeChild(textArea);
                }
            }
        });
    });
    
    // Handle delete user
    document.addEventListener("DOMContentLoaded", () => {
        document.body.addEventListener("click", (e) => {
            const deleteButton = e.target.closest(".delete-user-btn");
            if (deleteButton) {
                const userId = deleteButton.dataset.userId;
                const userName = deleteButton.closest("tr")?.querySelector("td:nth-child(2)")?.textContent || `User ${userId}`;
                
                if (confirm(`Are you sure you want to remove "${userName}" from monitoring?\n\nMessages from this user will no longer be tracked.`)) {
                    deleteButton.disabled = true;
                    deleteButton.innerHTML = `<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>`;
                    
                    fetch(`/api/config/users/${userId}`, {
                        method: "DELETE",
                    })
                        .then(response => {
                            if (!response.ok) {
                                return response.json().then(data => {
                                    throw new Error(data.message || "Failed to delete user");
                                });
                            }
                            return response.json();
                        })
                        .then(data => {
                            showToast(`User "${userName}" removed from monitoring`, "success");
                            setTimeout(() => {
                                window.location.reload();
                            }, 1500);
                        })
                        .catch(error => {
                            console.error("Failed to delete user:", error);
                            showToast(error.message || "Could not delete user", "error");
                            deleteButton.disabled = false;
                            deleteButton.innerHTML = `
                                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" class="bi bi-trash" viewBox="0 0 16 16">
                                    <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5m3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0z"/>
                                    <path d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4zM2.5 3h11V2h-11z"/>
                                </svg>
                            `;
                        });
                }
            }
        });
    });
    
    // Handle Clean DB button
    document.getElementById("btn-clean-db")?.addEventListener("click", async () => {
        // Confirm with strong warning
        const confirmation = confirm(
            "âš ï¸ WARNING: This will permanently delete ALL data!\n\n" +
            "This includes:\n" +
            "â€¢ All message records (database)\n" +
            "â€¢ All alerts history\n" +
            "â€¢ All feedback data\n" +
            "â€¢ All analytics history\n" +
            "â€¢ Live activity feed (Redis stream)\n" +
            "â€¢ Cached participant info\n\n" +
            "This action CANNOT be undone!\n\n" +
            "Are you absolutely sure you want to continue?"
        );
        
        if (!confirmation) {
            return;
        }
        
        // Double confirmation with input validation
        const doubleConfirm = prompt(
            "âš ï¸ FINAL CONFIRMATION\n\n" +
            "Type 'DELETE ALL' (in caps) to proceed:\n\n" +
            "This is your last chance to cancel!"
        );
        
        if (doubleConfirm !== "DELETE ALL") {
            if (doubleConfirm !== null) showToast("Confirmation cancelled", "info");
            return;
        }
        
        const button = document.getElementById("btn-clean-db");
        const originalText = button.innerHTML;
        
        try {
            button.disabled = true;
            button.innerHTML = '<span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span> Cleaning...';
            
            const response = await fetch("{{ url_for('api_clean_database') }}", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
            });
            
            if (!response.ok) {
                const data = await response.json();
                throw new Error(data.message || "Failed to clean database");
            }
            
            const result = await response.json();
            showToast(`Environment cleaned successfully! Removed ${result.deleted || 0} DB records and ${result.redis_cleared || 0} Redis items.`, "success");
            
            // Reload page after short delay to show fresh state
            setTimeout(() => {
                window.location.reload();
            }, 2000);
            
        } catch (error) {
            console.error("Clean DB error:", error);
            showToast(error.message || "Failed to clean database", "error");
            button.disabled = false;
            button.innerHTML = originalText;
        }
    });
</script>
{% endblock %}
